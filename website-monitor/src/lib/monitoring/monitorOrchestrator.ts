import { MonitoringService } from './monitor';
import { EmailService } from '@/lib/email/emailService';
import { getMonitorStore } from '@/lib/storage/monitorStore';
import { getHistoricalStore } from '@/lib/storage/historicalStore';
import { EmailNotification } from '@/lib/types';

export class MonitorOrchestrator {
  private monitoringService: MonitoringService;
  private emailService: EmailService;
  private store = getMonitorStore();
  private historicalStore = getHistoricalStore();

  constructor() {
    this.monitoringService = new MonitoringService();
    this.emailService = new EmailService();
  }

  async checkAllMonitors(): Promise<void> {
    const monitors = this.store.getAllMonitors();
    console.log(`Checking ${monitors.length} monitors...`);

    // Check all monitors in parallel
    const checkPromises = monitors.map(monitor => this.checkSingleMonitor(monitor.id));
    await Promise.allSettled(checkPromises);
  }

  async checkSingleMonitor(monitorId: string): Promise<void> {
    const monitor = this.store.getMonitor(monitorId);
    if (!monitor) {
      console.error(`Monitor ${monitorId} not found`);
      return;
    }

    try {
      // Perform the website check
      const result = await this.monitoringService.checkWebsite(monitor.url);
      
      // Record response time and status
      await this.historicalStore.addResponseTime(monitorId, {
        monitorId,
        timestamp: new Date(),
        responseTime: result.responseTime,
        status: result.status,
        statusCode: result.statusCode,
      });

      // Handle incidents
      const activeIncident = this.historicalStore.getActiveIncident(monitorId);
      
      if (result.status !== 'up' && !activeIncident) {
        // Start new incident
        const rootCause = result.error || 
          (result.status === 'ssl_error' ? 'SSL certificate issue' : 
           result.status === 'client_error' ? `HTTP ${result.statusCode} client error` :
           'Server not responding');
        
        await this.historicalStore.startIncident(monitorId, result.status, rootCause);
      } else if (result.status === 'up' && activeIncident) {
        // End active incident
        await this.historicalStore.endIncident(monitorId, activeIncident.id);
      }
      
      // Update monitor with results
      const updatedMonitor = await this.store.updateMonitor(monitorId, {
        lastStatus: result.status,
        lastChecked: new Date(),
        lastResponseTime: result.responseTime,
        lastStatusCode: result.statusCode,
        lastError: result.error,
        sslInfo: result.sslInfo,
      });

      if (!updatedMonitor) {
        console.error(`Failed to update monitor ${monitorId}`);
        return;
      }

      // Check if status changed and send notification
      if (monitor.lastStatus !== null && monitor.lastStatus !== result.status) {
        console.log(`Status changed for ${monitor.url}: ${monitor.lastStatus} â†’ ${result.status}`);
        
        const notification: EmailNotification = {
          to: monitor.email,
          subject: '', // Will be generated by email service
          websiteUrl: monitor.url,
          previousStatus: monitor.lastStatus,
          currentStatus: result.status,
          statusCode: result.statusCode,
          error: result.error,
          timestamp: new Date(),
          responseTime: result.responseTime,
          sslInfo: result.sslInfo,
        };

        try {
          await this.emailService.sendStatusChangeNotification(notification);
        } catch (error) {
          console.error(`Failed to send email notification for ${monitor.url}:`, error);
        }
      }
    } catch (error) {
      console.error(`Error checking monitor ${monitor.url}:`, error);
      
      // Record the error as a response time entry
      await this.historicalStore.addResponseTime(monitorId, {
        monitorId,
        timestamp: new Date(),
        responseTime: 0,
        status: 'down',
        statusCode: null,
      });
      
      // Update monitor with error state
      await this.store.updateMonitor(monitorId, {
        lastStatus: 'down',
        lastChecked: new Date(),
        lastError: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }

  async addAndCheckMonitor(url: string, email: string): Promise<void> {
    // Validate URL
    try {
      const urlObj = new URL(url);
      if (!['http:', 'https:'].includes(urlObj.protocol)) {
        throw new Error('URL must start with http:// or https://');
      }
    } catch (error) {
      throw new Error('Invalid URL format');
    }

    // Add monitor to store
    const monitor = await this.store.addMonitor(url, email);
    
    // Immediately check the monitor
    await this.checkSingleMonitor(monitor.id);
  }

  async toggleMonthlyMonitoring(monitorId: string, enabled: boolean): Promise<void> {
    await this.store.updateMonitor(monitorId, {
      monthlyMonitoringEnabled: enabled,
    });
  }
}

// Singleton instance
let orchestratorInstance: MonitorOrchestrator | null = null;

export function getMonitorOrchestrator(): MonitorOrchestrator {
  if (!orchestratorInstance) {
    orchestratorInstance = new MonitorOrchestrator();
  }
  return orchestratorInstance;
}